# AKKA

## ch01

##### 개념

* 오픈소스 툴킷
* JVM 상의 동시성과 분산 애플리케이션을 단순화하는 런타임
* 자바와 스칼라 언어 모두로 작성이 가능

##### 특징

* 객체의 메서드를 직접 호출할 수 없고, 오직 메세지를 전달할 수 있을뿐임
* 모든 것이 **비동기적**
* **블로킹 X**
* 모든 것이 **동시적**

***

* 스케일 업 : 컴퓨터에 CPU/메모리를 추가해 성능을 높이는 방식
* 스케일 아웃 : 별도의 컴퓨터를 추가해 병렬처리를 수행하는 것

***

##### 처리율

* 궁극적으로는 자바의 Thread/Task를 사용하는 것과 마찬가지임
* but, 프로그램에 존재하는 순차적 부분(블로킹 콜)을 전부 없애거나 최소한으로 만들 수 있음
* 블로킹/동기적 방식 사고  -> **논블로킹/비동기적 방식**

**아카를 이용한다** : 블로킹 호출이 일어나는 지점을 논블로킹 호출로 전환하는 작업을 수행한다.

***

##### 스케일 아웃

* 유연한 스케일. **탄력성** (스케일 업/다운, 아웃/인 자유자재로 지원)
* 클러스터 기능 제공

***

##### 모듈화(modularity)

* 클래스/객체 -> **액터** 중심
* 기존 객체 방식 : 서로의 메서드를 동기적인 방식으로 호출 -> 영향 끼침(결합)
* 액터 : 완벽하게 독립적, 오로지 메시지를 주고받는 방식
* 액터 모델을 구현한 라이브러리 'AKKA'
* 1. 반응성
  2. 탄력성
  3. 유연성
  4. 메시지 중심

***

### setting

* intellij plugins scala 설치
* new project -> scala -> sbt
* mvnrepository -> akka dependency 추가

***

## ch02

##### 액터시스템

* 모든 액터는 어떤 액터시스템 내부에서 동작을 수행함
* 액터시스템 : 액터를 담는 컨테이너
* 동일 액터시스템 안에서 동작하는 액터들은 아카 라이브러리가 제공하는 스레드 스케줄링, 구성파일, 로그 서비스 등을 공유함

```java
ActorSystem actorSystem = ActorSystem.create("TestSystem")
// 액터시스템 객체 생성
// TestSystem : 액터시스템 이름
```

***

##### 액터

* Props (프롭스)
  * 액터를 만드는 데 필요한 구성요소를 담는 일종의 구성파일 같은 클래스
  * 한 번 만들어지면 값을 변경할 수 없는 **불변객체**
    * 필요한 곳에서 자유롭게 공유할 수 있음

```java
ActorRef ping = actorSystem.actorOf(Props.create(PingActor.class),"PingActor");

// 만들려는 액터 클래스가 인수가 없는 기본 생성자를 사용하는 경우, 액터의 타입 정보만 전달하면 됨(PingActor.class)
// 만들려는 액터 클래스가 인수를 받아들이는 생성자를 사용하는 경우,(PingActor.class, "arg1", "arg2")와 같이 인수 전달

```

* 액터 이름
  * 액터시스템에서, 액터의 이름은 반드시 고유한 문자열이어야 함
    * 똑같은 이름 액터를 한 개 이상 만들 수 없다!
  * 액터는 트리와 비슷한 계층 구조
    * 경로라는 개념이 존재하며, 액터 이름은 이럴 경우 의미를 가짐
  * actorOf : 액터를 만들기 위한 팩토리 메서드
    * Props, 액터 이름을 인자로 받음
    * ActorSystem/ActorContext 객체로부터 호출 가능

***

##### ActorRef

* 액터를 가리키는 참조
* 모든 액터는 오직 ActorRef 타입에 의해서만 접근될 수 있다
* 액터 객체에 직접 접근 불가능
* UntypedActor(액터의 부모 클래스) 상속 -> 일반적인 자바 클래스처럼 생성자를 호출할 수 없음
  * 오직 Props를 통해서만 생성, ActorRef를 통해서만 접근 가능

***

##### 장소 투명성

* 내가 사용하는 액터가 물리적으로 어디에 존재하는 지 알 필요가 없음
  * 오직 ActorRef를 가지고 작업을 수행할 뿐이기 때문
* 여러 개의 JVM이 클러스터를 형성하는 클러스터링의 경우 큰 장점을 보임

***

##### 메시지 전송

```java
ping.tell("start", ActorRef.noSender());
```

* 'ping'이라는 ActorRef 객체에 'start'라는 문자열 객체를 메시지로 전송

* 객체지향 vs 액터

  * 객체지향 : 객체를 만든 다음 - 그 객체가 가지고 있는 메서드 호출

  * 액터 : 액터를 만든 다음 - 그 액터에 메시지를 전송

* ActorRef는 tell, ask 두 개의 API 제공

* **tell 메서드**

  * 두 개의 값을 인수로 받음 - 1. 메시지 / 2. 발신자
  * 메시지
    * 문자열 외에도, **임의의 자바 객체가 될 수 있음**
    * UntypedActor : 액터가 받아들이는 메시지의 타입이 정해져 있지 않음
  * 발신자
    * **반드시 ActorRef 타입이어야 함**
      1. getSelf() : 액터 자신의 ActorRef 객체 리턴 (자신을 발신자로 설정)
      2. getSender() : 메시지를 보내온 발신인의 주소를 다음 액터에게 그대로 포워드 할 경우 사용
      3. 어떤 특정 액터를 가리키는 ActorRef 객체
      4. ActorRef.noSender() : 개념적으로 null에 해당하는 액터 주소 리턴
         * 발신인 주소가 아무 의미 없는 경우에 사용

***

##### 메일박스

* 액터에 어떤 메시지를 전송하면, 액터마다 가지고 있는 메일박스에 저장됨
* 기본 제공 메일박스 : Java의 ConcurrentLinkedQueue를 이용해 구현
  * 메일박스의 종류에 따라 다른 클래스를 이용하기도 함
  * 최적의 메일박스 타입을 골라, 다양한 속성을 정의하는 것이 필요한 경우도 있음
* 전달되는 메시지가 메일박스에 쌓이고, 액터는 그 메시지를 한 번에 하나씩 처리

***

##### onReceive

* 액터시스템은 내부에 스레드풀을 보유함
  * 디스패처라고도 부름
* 일정한 규칙에 따라 스레드를 액터에게 할당
* -> 스레드가 할당된 액터는 메시지를 처리하고 스레드를 풀로 반납
* -> 액터시스템은 반납된 스레드를 다른 액터에게 다시 할당하는 방식

* 액터는 디스패처에 의해, 스레드가 할당되어야만 동작 수행 가능
* 과정
  1. 액터에 스레드 할당됨
  2. 메일박스에서 메시지 하나 꺼내기
  3. onReceive 메서드 호출, 메시지를 인수로 전달
  4. onReceive 동작 완료
  5. 1. 시간이 되었으면, 스레드 반납 후 다음 순서 대기
     2. 시간이 아직이면, 메일박스에서 다음 메시지 꺼내고 과정 반복
* 중요 사항 2가지
  1. 어느 특정 시점에서 보았을 때, 액터의 onReceive 메서드를 호출하는 스레드는 반드시 1개로 국한됨!
  2. 하지만, onReceive 호출 스레드가 계속 똑같은 스레드인 것은 아니다!
     * 하나의 시점의 스레드는 1개이지만, 시점이 달라지면 얼마든지 다른 스레드로 달라질 수 있다

***

##### Context()

* 모든 액터는 자신이 실행되는 액터시스템의 환경, 문맥 등 ActorContext에 접근할 수 있는 context() 메서드를 포함함
* **ActorContext** : 해당 액터의 관점에서 보이는 ActorSystem의 모습을 나타내는 객체

***

##### 라이프사이클

* 모든 액터는 다음과 같은 라이프사이클을 가짐
  * 생성
  * 재시작 : 액터시스템 어딘가에서 에러가 발생해 액터 인스턴스가 새로 만들어지는 것
    * 내부 저장된 액터객체를 버리고, 생성자를 다시 호출함으로써 새로 만드는 경우
  * 멈춤 : 액터 라이프사이클의 최종적인 종료
* 라이프사이클과 관련된 액터 메서드
  * preStart : 생성자 완료 직후에 실행
  * preStop : 액터 라이프사이클이 완전히 종료하기 전에 실행
  * preRestart : 재시작이 이루어지기 전에 실행
  * postRestart : 재시작이 이루어진 직후에 실행

***

## ch03

##### 아카 계층구조

* 어떤 액터가 다른 액터를 만들면, 두 액터 사이에는 부모-자식 관계가 형성됨
* 따라서, 하나의 액터시스템 안에서 만들어진 수많은 액터는 거대한 트리구조를 형성함
  * 계층 구조를 만드는 것!

***

##### 보내고 잊기

* 액터시스템에서 tell 메서드로 메시지를 전달하는 것 : 철저하게 **비동기적**
* tell 메서드 호출 시, 해당 메시지의 도착 여부와 무관하게 즉시 리턴 : **보내고 잊기**

***

##### 작업의 완료

* 모든 액터가 독립적이고, 비동기적인 동작으로 분해됨

* 비교 예제1 

  1. main이 'work' 메시지를 PingActor에 전달
  2. 핑액터는 그것을 자식 Ping1Actor에 전달
  3. Ping1Actor은 자신의 자식 Ping2Actor, Ping3Actor에 전달
  4. 각각의 2,3액터는 작업을 완료하면, 'done'을 sender에 전달
  5. 핑액터는 'done'을 두 번 받으면, 최종 결과를 출력함

  * 이 경우, 최종 결과 출력 시점에 2,3액터의 작업이 완료됨을 증명할 수 있음

* 비교 예제2

  ```java
  @Override
  public void onReceive(Object message) throws Exception {
    if (message instanceof String) { 
      String msg = (String)message; 
      if ("work".equals(msg)) {
        child1.tell("work", getSelf());
        child2.tell("work", getSelf());
        getSender().tell("done", getSelf());
      } 
    }
  }
  ```

  * 이 경우, 2,3액터에게 전달하는 작업이 수행되었음을 의미할 뿐, 실제 수행하는 작업의 상태와는 아무런 상관이 없음

* 비교 예제3

  ```java
  class Ping {
    public void foo() {
      Ping1 p1 = new Ping1();
      p1.work();
      System.out.println("all works are completed.");
    } 
  }
  class Ping1 {
    public void work() {
      Ping2 p2 = new Ping2(); 
      Ping3 p3 = new Ping3(); 
      p2.work();
      p3.work();
    } 
  }
  ```

  * 이 경우, 동기적인 메서드 호출이기 때문에, p1.work()이 리턴하는 것은 p2,p3의 작업이 종료된 다음이다.
  * 따라서 이 경우, 최종 결과 출력 시점에 2,3액터의 작업이 완료됨을 증명할 수 있음

***

##### 메시지 순서

* 메시지가 전달되는 순서는 비결정적임
* 아카에서 보장하는 메시지의 순서는 오직 발신자와 수신자가 동일한 경우
  * ex) A m1 B -> A m2 B 일 경우, B의 입장에서는 m1이 m2보다 빨리 도착

***

##### 테크닉

* 메시지의 순서가 보장되지 않아 발생하는 혼란을 줄이기 위해서 사용하는 방법들
* 예제1 - Count 변수 선언을 통해 도착 여부 확인
* 예제2 - 발신자의 주소를 자기 자신이 아닌, 메시지 발신자(getSender)로 설정

***

##### 액터의 내부 상태와 스레드

* count와 같은 객체 내부의 변수는 액터의 행위를 조절하는 **상태**에 해당함
* 액터는 대부분 이와 같은 내부 상태를 보유함
* 액터의 내부 상태는 멀티스레딩을 위한 안전장치로 보호하지 않아도 상관없음
  * 액터 내부 상태에 접근하는 것은 시점에 따라, **하나의 스레드로 국한되어 있기 때문**
* 주의)
  * 아카가 멀티스레드 관련 문제를 모두 해결해주는 것은 아니다.
    * onReceive 내부에서 외부의 객체에 접근하는 경우 등..
