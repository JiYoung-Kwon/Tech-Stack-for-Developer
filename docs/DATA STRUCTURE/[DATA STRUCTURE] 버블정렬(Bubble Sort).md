# [DATA STRUCTURE] 버블정렬(Bubble Sort)

:writing_hand: *Assembled by JiYoung-Kwon (2021-01-31)* 



## 1. 버블 정렬이란?

- 거품이 수면으로 올라오는 듯한 모습 때문에 붙여진 이름
- 서로 **인접한 두 원소를 비교**하여 큰 수(작은 수)를 뒤로 보내는 정렬 알고리즘
- **O(n2)** 의 시간 복잡도를 가짐

<br/>

## 2. 버블 정렬 과정

* *(<u>오름차순 정렬</u> 을 기준으로 정리하였음)*

* 인접한 자료를 비교하여 교환하면서 자료를 정렬함

  * [첫번째 자료와 두 번째 자료, 두 번째 자료와 세 번째 자료, ... 이런식]

* **한번 전체 반복을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동**

* 1회전 반복을 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어감

* 예제

  [![Bubble sort](https://camo.githubusercontent.com/3cd9d9be73cbb8c0215e3a74402998321a7556b95f36465253ba923c33feaeab/68747470733a2f2f7777772e70726f6772616d6d696e6773696d706c69666965642e636f6d2f696d616765732f632f627562626c652d736f72742e676966)](https://camo.githubusercontent.com/3cd9d9be73cbb8c0215e3a74402998321a7556b95f36465253ba923c33feaeab/68747470733a2f2f7777772e70726f6772616d6d696e6773696d706c69666965642e636f6d2f696d616765732f632f627562626c652d736f72742e676966)

  1. 수열의 왼쪽 끝에 있는 두 숫자를 비교한다.
     - First Pass
     - 6과 3 비교

  ------

  2. 비교한 결과 왼쪽 숫자가 오른쪽 숫자보다 크면 자리를 교환한다.

     2-1. 크지 않으면 교환하지 않고 넘어간다.

     * 6 > 3 이므로 숫자 교환

  ------

  3. 오른쪽으로 한칸 이동한 후, 동일한 방법으로 숫자를 비교한다.
     * 6과 0 비교
     * 6 > 0 이므로 숫자 교환

  ------

  4. 동일한 작업을 오른쪽 끝의 숫자에 이동하기 까지 반복한다.
     * 6과 5 비교 , 6 > 5이므로 교환
     * 6과 1 비교, 6 > 1이므로 교환

  ------

  5. 오른쪽 끝에 도착하며 수열 중 가장 큰 수가 오른쪽 끝으로 이동한다.

  ------

  6. 오른쪽 끝 숫자는 정렬을 끝낸 것으로 간주한다.

  ------

  7. 다시 왼쪽 끝에서 부터 작업을 시작한다.

  ------

  8. 동일한 작업을 모든 숫자가 정렬될 때까지 반복한다.

     * Second Pass

       * 3과 0 비교, 3 > 0 이므로 교환

       * 3과 5 비교, 3 < 5 이므로 그대로

       * 5와 1 비교, 5 > 1이므로 교환

       * 5 정렬 끝

     * Third Pass
     
       * 0과 3 비교, 0 < 3 이므로 그대로
     
       * 3과 1 비교, 3 > 1 이므로 교환
       * 3 정렬 끝
     
     * Fourth Pass
     
       * 0과 1 비교, 0 < 1 이므로 그대로
     

  ***

  9. 정렬 완료

  ***

<br/>

## 3. 버블 정렬의 특징

* **장점**

  - 구현이 매우 간단함

* **단점**

  - 순서에 맞지 않은 요소를 인접한 요소와 교환함

  - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서 배열의 모든 다른 요소들과 교체되어야 함

  - 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어남

    ```
    위 예제에서 3번 인덱스에 있는 5의 경우가 그러하다.
    ```

* 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 **거의 쓰이지 않음**

<br/>

## 5. 버블 정렬의 시간 복잡도

- **최선의 경우**

  - 자료가 이미 정렬되어 있는 경우

  - $$
    O(n^2)
    $$

    > 비교 횟수
    >
    > - n-1, n-2, ... , 2 ,1 번 = n(n-1)/2 번
    >
    > 교환 횟수
    >
    > - 일어나지 않음

- **최악의 경우**

  - 자료가 역순으로 정렬되어 있는 경우

  - $$
    O(n^2)
    $$

    > 비교 횟수
    >
    > - n(n-1)/2 번
    >
    > 교환 횟수
    >
    > - n(n-1)/2 번



## :bulb: 예상질문

Q1 - 버블정렬이 뭔가요?

A1 - 정렬 알고리즘 중에 하나로, 인접한 두 원소를 비교하고 교환하여 정렬하는 알고리즘입니다.

<br/>

Q2 - 버블정렬의 장단점은 뭔가요?

A2 - 버블정렬은 구현이 매우 간단하다는 장점이 있습니다. 하지만 한 요소를 오른 쪽으로 이동하기 위해 배열의 모든 다른 요소들과 교체해야 한다는 단점이 있습니다. 교환 작업이 이동 작업보다 더 복잡하기 때문에 단순성에도 불구하고 거의 쓰이지 않습니다.

<br/>

## :page_with_curl: Reference

- [[알고리즘\]버블 정렬 이란](https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html)
- [Bubble Sort](https://bowbowbow.tistory.com/10)
- [[알고리즘\]정렬 알고리즘-1](https://bowbowbow.tistory.com/10)
- [이미지 출처](https://www.programmingsimplified.com/c/source-code/c-program-bubble-sort)